
DECLARACION DE LIBRERIAS 
#include <stdio.h>
#include <math.h>
#include <time.h>
#include <unistd.h>  // Necesario para sleep
#include <stdlib.h>  // Necesario para setenv
Estas son las librerías necesarias para:

stdio.h: Entrada y salida estándar (por ejemplo, printf).
math.h: Funciones matemáticas (por ejemplo, sin, cos).
time.h: Funciones de manejo de tiempo (por ejemplo, time, localtime).
unistd.h: Funciones POSIX (por ejemplo, sleep).
stdlib.h: Funciones de utilidad general (por ejemplo, setenv).



#define PI 3.14159265359
Definimos el valor de PI para usar en cálculos matemáticos.

Funciones Auxiliares
Función es_bisiesto
c
Copiar código
int es_bisiesto(int ano) {
    if (ano % 4 == 0) {
        if (ano % 100 == 0) {
            if (ano % 400 == 0) {
                return 1;
            }
            return 0;
        }
        return 1;
    }
    return 0;
}

Esta función determina si un año es bisiesto. Un año es bisiesto si es divisible por 4, pero no por 100, excepto si también es divisible por 400.

Función calcular_numero_dias
c
Copiar código
int calcular_numero_dias(int mes, int dia, int ano) {
    int dias_por_mes[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    int N = dia;

    for (int i = 0; i < mes - 1; i++) {
        N += dias_por_mes[i];
    }

    if (mes > 2 && es_bisiesto(ano)) {
        N += 1;
    }

    return N;
}

Esta función calcula el número de días transcurridos desde el 1 de enero hasta una fecha específica. 
Tiene en cuenta los diferentes números de días en cada mes y ajusta para los años bisiestos.

Función calcular_angulo_declinacion
c
Copiar código
double calcular_angulo_declinacion(int N) {
    double Term_1 = -23.44;
    double Term_2 = (360.0 / 365.0) * (N + 10);
    double DS_rad = Term_2 * (PI / 180.0);
    double COSX = cos(DS_rad);
    double Decl = Term_1 * COSX;
    return Decl * (PI / 180.0);  // Convertir a radianes
}
Esta función calcula el ángulo de declinación solar para un día específico del año. La declinación solar es el ángulo entre los rayos del sol y el plano del ecuador de la Tierra.

Función calcular_ecuacion_tiempo
c
Copiar código
double calcular_ecuacion_tiempo(int N) {
    double B = (360.0 / 365.0) * (N - 81);
    B = B * (PI / 180.0);
    double EoT = 9.87 * sin(2 * B) - 7.53 * cos(B) - 1.5 * sin(B);
    return EoT;
}
Esta función calcula la ecuación del tiempo, que corrige la diferencia entre el tiempo solar aparente y el tiempo solar medio.

Función calcular_TSV
c
Copiar código
double calcular_TSV(double hr, double min, double Long, double EoT) {
    double hr_local = hr + (min / 60.0);
    double zona_hor = -5;  // Ajusta esta línea según tu zona horaria si es necesario
    double long_stand = zona_hor * 15;
    double TSV = hr_local + (((4 * (Long - long_stand)) + EoT) / 60.0);
    return TSV;
}
Esta función calcula el Tiempo Solar Verdadero (TSV) a partir de la hora local, la longitud del lugar y la ecuación del tiempo.

Función calcular_H
c
Copiar código
double calcular_H(double TSV) {
    double H = 15 * (TSV - 12);
    return H * (PI / 180.0);  // Convertir a radianes
}
Esta función calcula el ángulo horario H, que es el ángulo entre el meridiano del observador y el meridiano que pasa por el punto subsolar.

Función calcular_elevacion
c
Copiar código
double calcular_elevacion(double Decl, double Lat, double H) {
    return asin(sin(Decl) * sin(Lat) + cos(Decl) * cos(Lat) * cos(H));
}
Esta función calcula el ángulo de elevación solar, que es el ángulo entre el horizonte y el sol.

Función calcular_Azimut
c
Copiar código
double calcular_Azimut(double Decl, double Elev, double Lat, double H) {
    double Azim = acos((sin(Decl) - sin(Elev) * sin(Lat)) / (cos(Elev) * cos(Lat)));
    if (H > 0) {
        Azim = 2 * PI - Azim;
    }
    return Azim;
}
Esta función calcula el azimut solar, que es el ángulo de la dirección del sol en el horizonte.

Función main
c
Copiar código
int main() {
    double Lat = -3.99313 * (PI / 180.0);  // Convertir a radianes
    double Long = -79.20422;

    // Establecer zona horaria manualmente si es necesario (Ecuador: GMT-5)
    setenv("TZ", "America/Guayaquil", 1);
    tzset();

    while (1) {
        // Obtener la fecha y hora actuales
        time_t now = time(NULL);
        struct tm *tm = localtime(&now);
        int dia = tm->tm_mday;
        int mes = tm->tm_mon + 1;
        int ano = tm->tm_year + 1900;
        int hr = tm->tm_hour;
        int min = tm->tm_min;

        // Redondear la hora al intervalo de 5 minutos más cercano
        if (min % 5 >= 2.5) {
            min = (min / 5 + 1) * 5;
        } else {
            min = (min / 5) * 5;
        }
        if (min == 60) {
            min = 0;
            hr += 1;
        }

        // Calcular el número de días transcurridos
        int N = calcular_numero_dias(mes, dia, ano);

        // Calcular el ángulo de declinación solar
        double Decl = calcular_angulo_declinacion(N);

        // Calcular la ecuación del tiempo
        double EoT = calcular_ecuacion_tiempo(N);

        // Calcular el tiempo solar verdadero
        double TSV = calcular_TSV(hr, min, Long, EoT);

        // Calcular la hora GMT
        double H = calcular_H(TSV);

        // Calcular la elevación solar
        double Elev = calcular_elevacion(Decl, Lat, H);

        // Calcular el azimut solar
        double Azimut = calcular_Azimut(Decl, Elev, Lat, H);

        // Convertir resultados a grados para imprimir
        Elev *= (180.0 / PI);
        Azimut *= (180.0 / PI);

        // Imprimir resultados
        printf("Fecha: %d/%d/%d\n", dia, mes, ano);
        printf("Coordenadas: %.7f, %.7f\n", -3.99313, -79.20422);
        printf("Hora\t\tElevación\tAzimut\n");
        printf("%02d:%02d:00\t%.2f\t\t%.2f\n", hr, min, Elev, Azimut);

        // Esperar 5 minutos
        sleep(300);
    }

    return 0;
}
Explicación Detallada
Inicialización de Variables de Latitud y Longitud:

c
Copiar código
double Lat = -3.99313 * (PI / 180.0);  // Convertir a radianes
double Long = -79.20422;
Establecer la Zona Horaria:

c
Copiar código
setenv("TZ", "America/Guayaquil", 1);
tzset();
Bucle Infinito:

c
Copiar código
while (1) {
    // Obtener la fecha y hora actuales
    ...
}
Dentro del bucle:

Obtener la fecha y hora actuales.
Redondear la hora al intervalo de 5 minutos más cercano.
Calcular el número de días transcurridos desde el inicio del año.
Calcular el ángulo de declinación solar.
Calcular la ecuación del tiempo.
Calcular el tiempo solar verdadero.
Calcular la hora GMT.
Calcular la elevación solar.
Calcular el azimut solar.
Convertir los resultados a grados.
Imprimir los resultados.
Espera de 5 minutos:

c
Copiar código
sleep(300);
Este código realiza un bucle infinito que actualiza y muestra la elevación y el azimut solar cada 5 minutos en función de la hora local de la ubicación especificada (Ecuador).
